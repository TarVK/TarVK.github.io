{"pageProps":{"url":"https://tarvk.github.io/projects/faces-in-plane","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(PageSummary, {\n    title: \"Faces in plane\",\n    content: mdx(\"img\", {\n      src: \"~/banner.png\"\n    }),\n    tags: [\"Faces\", \"geometry\", \"geometric\", \"algorithm\"],\n    links: [{\n      type: \"github\",\n      url: \"https://github.com/TarVK/faces-in-plane\"\n    }, {\n      type: \"demo\",\n      url: \"https://tarvk.github.io/faces-in-plane/demo/build/\"\n    }],\n    mdxType: \"PageSummary\"\n  }, mdx(\"p\", null, \"This is an algorithm that is able to find the distinct faces formed by putting multiple simple polygons in the same plane.\")), mdx(\"section\", {\n    \"name\": \"Faces in plane\",\n    \"depth\": 1\n  }, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Faces in plane\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"I took a Geometric Algorithms course in which we learned various common techniques used in designing algorithms for geometric problems. In this course we also had to make a simple game using some geometric algorithms in small groups. The game itself wasn't very interesting or worth mentioning, but it did require me to come up with an interesting algorithm, which I implemented here in TypeScript.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This algorithm takes a set of simple polygons as an input. Simple polygons are shapes constructed from a list of points, where the boundary consists of the chain of segments between consecutive points (and the first and last point). Simple polygons additionally don't allow any of these segments to intersect. For instance the point list \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[{x: 0, y: 0}, {x: 10, y: 0}, {x: 5, y: 10}]\"), \" describes a simple triangle polygon:\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"~/triangle.png\",\n    \"alt\": \"triangle\"\n  })), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The algorithm then combines all of these polygons by projecting them on the same plane, and seeing what faces (areas) are formed (based on how the polygons intersect each other). These faces are also described by simple polygons in the output. In the implementation of my algorithm I allow additional data to be attached to polygons. This data is used in the output polygons to encode the input polygons that overlap with this face.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The goal of the algorithm is essentially to take a set of overlapping polygons, and produce a set of equivalent non-overlapping polygons, in a way that no information is lost.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Consider for instance the following input consisting of two triangles:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const polygon1 = {\\n    data: 1,\\n    polygon: [\\n        {x: 0, y: 0},\\n        {x: 10, y: 0},\\n        {x: 5, y: 10},\\n    ],\\n};\\nconst polygon2 = {\\n    data: 2,\\n    polygon: [\\n        {x: 0, y: 10},\\n        {x: 10, y: 10},\\n        {x: 5, y: 0},\\n    ],\\n};\\nconst input = [polygon1, polygon2];\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"which is drawn as:\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"~/exampleInput.png\",\n    \"alt\": \"triangle\"\n  })), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"When running the algorithm on this input, 5 independent faces will be found, and each face will specify what polygons it was constructed from:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"spoiler=true\",\n    \"spoiler\": \"true\"\n  }, \"const output = [\\n    {\\n        data: [polygon1],\\n        polygon: [\\n            {x: 0, y: 0},\\n            {x: 5, y: 0},\\n            {x: 2.5, y: 5},\\n        ],\\n    },\\n    {\\n        data: [polygon1, polygon2],\\n        polygon: [\\n            {x: 2.5, y: 5},\\n            {x: 5, y: 0},\\n            {x: 7.5, y: 5},\\n            {x: 5, y: 10},\\n        ],\\n    },\\n    {\\n        data: [polygon1],\\n        polygon: [\\n            {x: 5, y: 0},\\n            {x: 10, y: 0},\\n            {x: 7.5, y: 5},\\n        ],\\n    },\\n    {\\n        data: [polygon2],\\n        polygon: [\\n            {x: 0, y: 10},\\n            {x: 2.5, y: 5},\\n            {x: 5, y: 10},\\n        ],\\n    },\\n    {\\n        data: [polygon2],\\n        polygon: [\\n            {x: 5, y: 10},\\n            {x: 7.5, y: 5},\\n            {x: 10, y: 10},\\n        ],\\n    },\\n];\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"which is drawn as:\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"~/exampleOutput.png\",\n    \"alt\": \"triangle\"\n  })), mdx(\"section\", {\n    parentName: \"section\",\n    \"name\": \"Algorithm\",\n    \"depth\": 2\n  }, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Algorithm\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Given an input with a total of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" vertices (points of polygons) where the algorithm produces an output consisting of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"k\"), \" polygons, the algorithm can run in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O((n + k) * log n)\"), \"time. My specific implementation in TypeScript is slightly less efficient though, and given a maximum of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s\"), \" overlapping polygons in the input, runs in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O((n + k) * (s + log n))\"), \" time.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"I will glans over some basic aspects of the algorithm here, but it's described in more detail in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/TarVK/faces-in-plane/blob/main/explanation/algorithm.pdf\"\n  }, \"algorithm.pdf\"), \".\\nThe algorithm is based on the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Sweep_line_algorithm\"\n  }, \"sweep-line technique\"), \". This is a technique where the algorithm sweeps a virtual scan-line across the plane, and builds up the output when relevant points are passed. An example of this is illustrated in the gif below (taken from wikipedia) that shows-off Fortunes-algorithm for computing voronoi-diagrams:\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://upload.wikimedia.org/wikipedia/commons/2/25/Fortunes-algorithm.gif\",\n    \"alt\": \"sweep example\"\n  })), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Note however that this sweep line doesn't really go through all possible positions on a plane, since there's an infinite number of these. One could do an approximation and take an arbitrary step size to move the sweep line by to ensure there's only a finite number of steps to consider, but this would lead to inaccurate results. We can do much better, decreasing the number of positions to consider while increasing the precision: we simply only consider \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"event points\"), \". These event points define the coordinates at which interesting things occur, and our data has to be updated.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"My algorithm performs a vertical sweep of the plane, and keeps track of the different intervals formed by polygons on the scan-line. Below is an image showing two diamond polygons and a green scan-line:\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"~/intersectionScanline.png\",\n    \"alt\": \"intersection scanline\"\n  })), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The algorithm tracks these discrete regions formed on the scanline: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i1\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i2\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i3\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i4\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i5\"), \". For each of these regions it will store what the left and right boundary segments are (if any), and the set of polygons that are in this region. For instance regions \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i1\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i5\"), \" only have a single boundary each and contain no polygons. Regions \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i2\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i4\"), \" have 2 boundaries each, and each contain one of the diamond polygons. Lastly region \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i3\"), \" has 2 boundaries and contains both diamond polygons.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"In this image the sweep-line is drawn at a random position, but in reality this drawn position is never considered. We're only interested in maintaining an accurate representation of the information above, meaning we only have to consider points at which this information changes. This happens at any corner of any polygon in the input, as well as any intersection of segments. These event points are stored in a sorted queue, such that we can easily extract what the next event is that will occur. Each of the polygons' corners are thrown in this queue at the start of the algorithm, and any intersections are computed as the scan-line is moving. When a region is added or removed from the scan-line, any nearby regions are checked for whether their boundaries might intersect in the future, and such event points are added to the queue. This way we don't have to check for intersection between all segments in the input (a quadratic number), but only have to consider segments that have a real chance of intersecting.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"While this sweep is occurring, relevant data about the regions is also stored in a separate data structure. After executing the entire sweep, this data is used to reconstruct all faces that were encountered.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Everything is a little more nuanced than described here, but this captures the basic idea behind the algorithm. The algorithm for instance also has to deal with many edge cases that occur when polygons have corners at the same y-coordinates, or even when multiple polygons share the exact same corners. These edge cases have been considered before working out the algorithm, and it seems to handle them well. Problems however still occur when a point lies on the boundary of another polygon. This is caused by rounding errors, where one part in the algorithm may think the point lies left of the boundary and another part thinks it lies right of it, where as in reality it lies exactly on it. These types of problems are known as robustness issues, and I couldn't solve them for my algorithm despite my best effort. I also didn't consider such possible issues well enough in the initial designing phase, and instead only considered them after having encountered them in practice with my TypeScript implementation.\")), mdx(\"section\", {\n    parentName: \"section\",\n    \"name\": \"Demo\",\n    \"depth\": 2\n  }, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Demo\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"An implementation of the algorithm can be found at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/TarVK/faces-in-plane\"\n  }, \"github.com/TarVK/faces-in-plane\"), \".\\nThe algorithm is also accompanied by a demo webpage, at which the algorithm can be tested: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://tarvk.github.io/faces-in-plane/demo/build/\"\n  }, \"tarvk.github.io/faces-in-plane/demo\"), \".\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"~/banner.png\",\n    \"alt\": \"UI\"\n  })), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"For this demo site I made the polygon editor from scratch, sine I couldn't find any existing library for this that looked decent. This editor makes use of SVGs for drawing the polygons. I also made a way of directly editing and viewing the text representation of the polygons:\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"~/codeEditor.png\",\n    \"alt\": \"code editor\"\n  })), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"In this demo the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \" field of the output contains the concatenation of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \" of the source polygons at this face, rather than the whole source polygon. This was done to keep the output data more readable and less cluttered. Part of the code for this editor has also been reused in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/projects/sweeper\"\n  }, \"Sweeper\"), \" since I needed a 2d shape editor here too.\"))));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<section><style data-emotion=\"css nn640c\">.css-nn640c{-webkit-text-decoration:none;text-decoration:none;color:inherit;}</style><a href=\"#faces-in-plane\" class=\"css-nn640c\"><h1>Faces in plane</h1></a><p>I took a Geometric Algorithms course in which we learned various common techniques used in designing algorithms for geometric problems. In this course we also had to make a simple game using some geometric algorithms in small groups. The game itself wasn&#x27;t very interesting or worth mentioning, but it did require me to come up with an interesting algorithm, which I implemented here in TypeScript.</p><p>This algorithm takes a set of simple polygons as an input. Simple polygons are shapes constructed from a list of points, where the boundary consists of the chain of segments between consecutive points (and the first and last point). Simple polygons additionally don&#x27;t allow any of these segments to intersect. For instance the point list <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">[{x:&nbsp;0,&nbsp;y:&nbsp;0},&nbsp;{x:&nbsp;10,&nbsp;y:&nbsp;0},&nbsp;{x:&nbsp;5,&nbsp;y:&nbsp;10}]</code> describes a simple triangle polygon:</p><p><img alt=\"triangle\" src=\"/pages\\1-projects\\Faces-in-plane/triangle.png\" style=\"max-width:100%\"/></p><p>The algorithm then combines all of these polygons by projecting them on the same plane, and seeing what faces (areas) are formed (based on how the polygons intersect each other). These faces are also described by simple polygons in the output. In the implementation of my algorithm I allow additional data to be attached to polygons. This data is used in the output polygons to encode the input polygons that overlap with this face.</p><p>The goal of the algorithm is essentially to take a set of overlapping polygons, and produce a set of equivalent non-overlapping polygons, in a way that no information is lost.</p><p>Consider for instance the following input consisting of two triangles:</p><style data-emotion=\"css 1x06cmw\">.css-1x06cmw{box-shadow:0px 0px 30px -5px rgba(0,0,0,0.3);border-radius:10px;overflow:hidden;margin-bottom:8px;}.css-1x06cmw .linenumber{min-width:30px!important;color:#AAA!important;}.css-1x06cmw span{word-break:break-all;}</style><div class=\"css-1x06cmw\"><style data-emotion=\"css 1rf12ws\">.css-1rf12ws{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;background-color:#EEEEEE;}.css-1rf12ws .MuiButtonBase-root{padding:8px;border-radius:50%;}</style><div class=\"css-1rf12ws\"><div class=\"MuiBox-root jss1\"></div><button class=\"MuiButtonBase-root MuiIconButton-root\" tabindex=\"0\" type=\"button\" aria-label=\"Copy code to clipboard\" title=\"Copy code\"><span class=\"MuiIconButton-label\"><svg class=\"MuiSvgIcon-root\" focusable=\"false\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z\"></path></svg></span></button><button class=\"MuiButtonBase-root MuiIconButton-root\" tabindex=\"0\" type=\"button\" aria-label=\"Toggle line numbers\" title=\"Toggle line numbers\"><span class=\"MuiIconButton-label\"><svg class=\"MuiSvgIcon-root\" focusable=\"false\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z\"></path></svg></span></button><style data-emotion=\"css 1739oy8\">.css-1739oy8{z-index:1;}</style><div class=\"MuiBackdrop-root css-1739oy8\" aria-hidden=\"true\" style=\"opacity:0;visibility:hidden\"><div></div></div></div><code class=\"language-js undefined\" style=\"color:#393A34;font-family:&quot;Consolas&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace;direction:ltr;text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;font-size:11px;line-height:14px;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;display:block;background-color:#FAFAFA;padding:8px\"><span style=\"flex-wrap:wrap\"><span class=\"token\" style=\"color:#0000ff\">const</span><span> polygon1 </span><span class=\"token\" style=\"color:#393A34\">=</span><span> </span><span class=\"token\" style=\"color:#393A34\">{</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    data</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">1</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    polygon</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span></span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">;</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span></span><span class=\"token\" style=\"color:#0000ff\">const</span><span> polygon2 </span><span class=\"token\" style=\"color:#393A34\">=</span><span> </span><span class=\"token\" style=\"color:#393A34\">{</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    data</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">2</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    polygon</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span></span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">;</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span></span><span class=\"token\" style=\"color:#0000ff\">const</span><span> input </span><span class=\"token\" style=\"color:#393A34\">=</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>polygon1</span><span class=\"token\" style=\"color:#393A34\">,</span><span> polygon2</span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">;</span></span></code></div><p>which is drawn as:</p><p><img alt=\"triangle\" src=\"/pages\\1-projects\\Faces-in-plane/exampleInput.png\" style=\"max-width:100%\"/></p><p>When running the algorithm on this input, 5 independent faces will be found, and each face will specify what polygons it was constructed from:</p><style data-emotion=\"css 1x06cmw\">.css-1x06cmw{box-shadow:0px 0px 30px -5px rgba(0,0,0,0.3);border-radius:10px;overflow:hidden;margin-bottom:8px;}.css-1x06cmw .linenumber{min-width:30px!important;color:#AAA!important;}.css-1x06cmw span{word-break:break-all;}</style><div metastring=\"spoiler=true\" class=\"css-1x06cmw\"><style data-emotion=\"css 1rf12ws\">.css-1rf12ws{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;background-color:#EEEEEE;}.css-1rf12ws .MuiButtonBase-root{padding:8px;border-radius:50%;}</style><div class=\"css-1rf12ws\"><div class=\"MuiBox-root jss2\"></div><button class=\"MuiButtonBase-root MuiIconButton-root\" tabindex=\"0\" type=\"button\" aria-label=\"Copy code to clipboard\" title=\"Copy code\"><span class=\"MuiIconButton-label\"><svg class=\"MuiSvgIcon-root\" focusable=\"false\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z\"></path></svg></span></button><button class=\"MuiButtonBase-root MuiIconButton-root\" tabindex=\"0\" type=\"button\" aria-label=\"Toggle line numbers\" title=\"Toggle line numbers\"><span class=\"MuiIconButton-label\"><svg class=\"MuiSvgIcon-root\" focusable=\"false\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z\"></path></svg></span></button><style data-emotion=\"css 1739oy8\">.css-1739oy8{z-index:1;}</style><div class=\"MuiBackdrop-root css-1739oy8\" aria-hidden=\"true\" style=\"opacity:0;visibility:hidden\"><div></div></div></div><details><style data-emotion=\"css 1iuj5ih\">.css-1iuj5ih{padding-left:8px;}</style><summary class=\"css-1iuj5ih\">View code</summary> <code class=\"language-js undefined\" style=\"color:#393A34;font-family:&quot;Consolas&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace;direction:ltr;text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;font-size:11px;line-height:14px;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;display:block;background-color:#FAFAFA;padding:8px\"><span style=\"flex-wrap:wrap\"><span class=\"token\" style=\"color:#0000ff\">const</span><span> output </span><span class=\"token\" style=\"color:#393A34\">=</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">{</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        data</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>polygon1</span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        polygon</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">2.5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">{</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        data</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>polygon1</span><span class=\"token\" style=\"color:#393A34\">,</span><span> polygon2</span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        polygon</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">2.5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">7.5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">{</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        data</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>polygon1</span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        polygon</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">7.5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">{</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        data</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>polygon2</span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        polygon</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">0</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">2.5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">{</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        data</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>polygon2</span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        polygon</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#393A34\">[</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">7.5</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">5</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>            </span><span class=\"token\" style=\"color:#393A34\">{</span><span>x</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">,</span><span> y</span><span class=\"token\" style=\"color:#393A34\">:</span><span> </span><span class=\"token\" style=\"color:#36acaa\">10</span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>        </span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span>    </span><span class=\"token\" style=\"color:#393A34\">}</span><span class=\"token\" style=\"color:#393A34\">,</span><span>\n</span></span><span style=\"flex-wrap:wrap\"><span></span><span class=\"token\" style=\"color:#393A34\">]</span><span class=\"token\" style=\"color:#393A34\">;</span></span></code></details></div><p>which is drawn as:</p><p><img alt=\"triangle\" src=\"/pages\\1-projects\\Faces-in-plane/exampleOutput.png\" style=\"max-width:100%\"/></p><section><style data-emotion=\"css nn640c\">.css-nn640c{-webkit-text-decoration:none;text-decoration:none;color:inherit;}</style><a href=\"#algorithm\" class=\"css-nn640c\"><h2>Algorithm</h2></a><p>Given an input with a total of <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">n</code> vertices (points of polygons) where the algorithm produces an output consisting of <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">k</code> polygons, the algorithm can run in <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">O((n&nbsp;+&nbsp;k)&nbsp;*&nbsp;log&nbsp;n)</code>time. My specific implementation in TypeScript is slightly less efficient though, and given a maximum of <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">s</code> overlapping polygons in the input, runs in <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">O((n&nbsp;+&nbsp;k)&nbsp;*&nbsp;(s&nbsp;+&nbsp;log&nbsp;n))</code> time.</p><p>I will glans over some basic aspects of the algorithm here, but it&#x27;s described in more detail in <a href=\"https://github.com/TarVK/faces-in-plane/blob/main/explanation/algorithm.pdf\" class=\"css-0\">algorithm.pdf</a>.\nThe algorithm is based on the <a href=\"https://en.wikipedia.org/wiki/Sweep_line_algorithm\" class=\"css-0\">sweep-line technique</a>. This is a technique where the algorithm sweeps a virtual scan-line across the plane, and builds up the output when relevant points are passed. An example of this is illustrated in the gif below (taken from wikipedia) that shows-off Fortunes-algorithm for computing voronoi-diagrams:</p><p><img alt=\"sweep example\" src=\"https://upload.wikimedia.org/wikipedia/commons/2/25/Fortunes-algorithm.gif\" style=\"max-width:100%\"/></p><p>Note however that this sweep line doesn&#x27;t really go through all possible positions on a plane, since there&#x27;s an infinite number of these. One could do an approximation and take an arbitrary step size to move the sweep line by to ensure there&#x27;s only a finite number of steps to consider, but this would lead to inaccurate results. We can do much better, decreasing the number of positions to consider while increasing the precision: we simply only consider <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">event&nbsp;points</code>. These event points define the coordinates at which interesting things occur, and our data has to be updated.</p><p>My algorithm performs a vertical sweep of the plane, and keeps track of the different intervals formed by polygons on the scan-line. Below is an image showing two diamond polygons and a green scan-line:</p><p><img alt=\"intersection scanline\" src=\"/pages\\1-projects\\Faces-in-plane/intersectionScanline.png\" style=\"max-width:100%\"/></p><p>The algorithm tracks these discrete regions formed on the scanline: <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i1</code>, <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i2</code>, <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i3</code>, <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i4</code>, and <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i5</code>. For each of these regions it will store what the left and right boundary segments are (if any), and the set of polygons that are in this region. For instance regions <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i1</code> and <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i5</code> only have a single boundary each and contain no polygons. Regions <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i2</code> and <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i4</code> have 2 boundaries each, and each contain one of the diamond polygons. Lastly region <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">i3</code> has 2 boundaries and contains both diamond polygons.</p><p>In this image the sweep-line is drawn at a random position, but in reality this drawn position is never considered. We&#x27;re only interested in maintaining an accurate representation of the information above, meaning we only have to consider points at which this information changes. This happens at any corner of any polygon in the input, as well as any intersection of segments. These event points are stored in a sorted queue, such that we can easily extract what the next event is that will occur. Each of the polygons&#x27; corners are thrown in this queue at the start of the algorithm, and any intersections are computed as the scan-line is moving. When a region is added or removed from the scan-line, any nearby regions are checked for whether their boundaries might intersect in the future, and such event points are added to the queue. This way we don&#x27;t have to check for intersection between all segments in the input (a quadratic number), but only have to consider segments that have a real chance of intersecting.</p><p>While this sweep is occurring, relevant data about the regions is also stored in a separate data structure. After executing the entire sweep, this data is used to reconstruct all faces that were encountered.</p><p>Everything is a little more nuanced than described here, but this captures the basic idea behind the algorithm. The algorithm for instance also has to deal with many edge cases that occur when polygons have corners at the same y-coordinates, or even when multiple polygons share the exact same corners. These edge cases have been considered before working out the algorithm, and it seems to handle them well. Problems however still occur when a point lies on the boundary of another polygon. This is caused by rounding errors, where one part in the algorithm may think the point lies left of the boundary and another part thinks it lies right of it, where as in reality it lies exactly on it. These types of problems are known as robustness issues, and I couldn&#x27;t solve them for my algorithm despite my best effort. I also didn&#x27;t consider such possible issues well enough in the initial designing phase, and instead only considered them after having encountered them in practice with my TypeScript implementation.</p></section><section><style data-emotion=\"css nn640c\">.css-nn640c{-webkit-text-decoration:none;text-decoration:none;color:inherit;}</style><a href=\"#demo\" class=\"css-nn640c\"><h2>Demo</h2></a><p>An implementation of the algorithm can be found at <a href=\"https://github.com/TarVK/faces-in-plane\" class=\"css-0\">github.com/TarVK/faces-in-plane</a>.\nThe algorithm is also accompanied by a demo webpage, at which the algorithm can be tested: <a href=\"https://tarvk.github.io/faces-in-plane/demo/build/\" class=\"css-0\">tarvk.github.io/faces-in-plane/demo</a>.</p><p><img alt=\"UI\" src=\"/pages\\1-projects\\Faces-in-plane/banner.png\" style=\"max-width:100%\"/></p><p>For this demo site I made the polygon editor from scratch, sine I couldn&#x27;t find any existing library for this that looked decent. This editor makes use of SVGs for drawing the polygons. I also made a way of directly editing and viewing the text representation of the polygons:</p><p><img alt=\"code editor\" src=\"/pages\\1-projects\\Faces-in-plane/codeEditor.png\" style=\"max-width:100%\"/></p><p>In this demo the <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">data</code> field of the output contains the concatenation of the <style data-emotion=\"css 1ofz18t\">.css-1ofz18t{display:inline-block;background-color:#f6f6f6;border-radius:5px;word-break:break-word;}</style><code class=\"css-1ofz18t\">data</code> of the source polygons at this face, rather than the whole source polygon. This was done to keep the output data more readable and less cluttered. Part of the code for this editor has also been reused in <a href=\"/projects/sweeper\" class=\"css-0\">Sweeper</a> since I needed a 2d shape editor here too.</p></section></section>","scope":{}},"urlBase":"/pages\\1-projects\\Faces-in-plane","ToC":[{"name":"Faces in plane","children":[{"name":"Algorithm","children":[]},{"name":"Demo","children":[]}]}],"shareData":{"title":"Faces in plane","description":"This is an algorithm that is able to find the distinct faces formed by putting multiple simple polygons in the same plane.","tags":["Faces","geometry","geometric","algorithm"]},"links":[{"type":"github","url":"https://github.com/TarVK/faces-in-plane"},{"type":"demo","url":"https://tarvk.github.io/faces-in-plane/demo/build/"}],"index":{"rootPath":"","items":[{"name":"projects","orderIndex":1,"opened":true,"hasIndex":false,"children":[{"name":"Faces-in-plane","opened":false,"hasIndex":true,"children":[],"selected":true},{"name":"LaunchMenu","opened":false,"hasIndex":true,"children":[]},{"name":"SAT","opened":false,"hasIndex":true,"children":[]},{"name":"Sweeper","opened":false,"hasIndex":true,"children":[]},{"name":"Waddles","opened":false,"hasIndex":true,"children":[]},{"name":"Hidden-blades","orderIndex":100,"opened":false,"hasIndex":true,"children":[]}]},{"name":"articles","orderIndex":2,"opened":false,"hasIndex":false,"children":[{"name":"Lambda-calculus","opened":false,"hasIndex":true,"children":[]}]},{"name":"hobbies","orderIndex":3,"opened":false,"hasIndex":false,"children":[{"name":"3D-modelling","opened":false,"hasIndex":true,"children":[]},{"name":"juggling","opened":false,"hasIndex":true,"children":[]},{"name":"parkour","opened":false,"hasIndex":true,"children":[]}]}]}},"__N_SSG":true}